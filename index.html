<html>
<head>
    <title>Poincare' Kaleidoscope</title>
    <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1" />
    <script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
    <script type="text/javascript" src="webgl-utils.js"></script>
    <script type="text/javascript" src="Complex.js"></script>
    <script type="text/javascript" src="Circline.js"></script>
    <script type="text/javascript" src="Disc.js"></script>
    <script type="text/javascript" src="jpg.js"></script>
    <script id="shader-mobius-vertex" type="x-shader/x-vertex">
			attribute vec3 aVertexPosition;
			attribute vec2 aTextureCoord;

			uniform vec2 uMobiusA;
			uniform vec2 uMobiusB;
			uniform vec2 uMobiusC;
			uniform vec2 uMobiusD;

			varying vec2 pos;

			varying vec2 vTextureCoord;

			vec2 cMultiply(in vec2 a, in vec2 b) {
			return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
			}

			vec2 cDivide(in vec2 a, in vec2 b) {
			float automorphy = b.x * b.x + b.y * b.y;
			return vec2((a.x * b.x + a.y * b.y) / automorphy, (a.y * b.x - a.x * b.y) / automorphy);
			}

			void main(void) {
			    pos.x = aVertexPosition.x;
			    pos.y = aVertexPosition.y;

			    pos = cDivide(
			    cMultiply(uMobiusA, pos) + uMobiusB,
			    cMultiply(uMobiusC, pos) + uMobiusD
			    );

			    gl_Position =  vec4(pos, 0.0, 1.0);
			    vTextureCoord = aTextureCoord;
			}
    </script>
    <script id="shader-mobius-fragment" type="x-shader/x-fragment">
			precision mediump float;

			varying vec2 vTextureCoord;

			uniform sampler2D uSampler;
			uniform vec2 vTextureOffset;

			void main(void) {
			gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t) - vTextureOffset);
			}
    </script>
    <script id="shader-basic-vertex" type="x-shader/x-vertex">
			attribute vec3 aVertexPosition;

            void main(void) {
			    gl_Position = vec4(aVertexPosition, 1.0);
            }
    </script>
    <script id="shader-circlegradient-fragment" type="x-shader/x-fragment">
			precision mediump float;

			uniform vec4 uColor0, uColor1;
            uniform float uR0, uR1;

			void main(void) {
                float x = gl_PointCoord.x ;
                float y = gl_PointCoord.y ;
                float radiusSquared = x * x + y * y;
                float r0Squared = uR0 * uR0;
                float r1Squared = uR1 * uR1;

                if (r0Squared > radiusSquared || radiusSquared > r1Squared) {
                    gl_FragColor = vec4(0, 0, 0, 0);
                } else {
                    float ratio = (radiusSquared - r0Squared) / (r1Squared - r0Squared);
			        gl_FragColor = mix(uColor0, uColor1, ratio);
                }

			}
    </script>
    <script type="text/javascript">
        var gl;

        function initGL(canvas) {
            try {
                gl = doc.canvas.getContext("experimental-webgl");
                gl.viewportWidth = canvas.width;
                gl.viewportHeight = canvas.height;
            } catch (e) {
            }
            if (!gl) {
                alert("Could not initialise WebGL, sorry :-(");
            }
        }

        function getShader(gl, id) {
            var shaderScript = document.getElementById(id);
            if (!shaderScript) {
                return null;
            }

            var str = "";
            var k = shaderScript.firstChild;
            while (k) {
                if (k.nodeType == 3) {
                    str += k.textContent;
                }
                k = k.nextSibling;
            }

            var shader;
            if (shaderScript.type == "x-shader/x-fragment") {
                shader = gl.createShader(gl.FRAGMENT_SHADER);
            } else if (shaderScript.type == "x-shader/x-vertex") {
                shader = gl.createShader(gl.VERTEX_SHADER);
            } else {
                return null;
            }

            gl.shaderSource(shader, str);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert(gl.getShaderInfoLog(shader));
                return null;
            }

            return shader;
        }

        var mobiusShaderProgram;
        var circleGradientShaderProgram;
        function initShaders() {
            var mobiusVertexShader = getShader(gl, "shader-mobius-vertex");
            var mobiusFragmentShader = getShader(gl, "shader-mobius-fragment");

            mobiusShaderProgram = gl.createProgram();
            gl.attachShader(mobiusShaderProgram, mobiusVertexShader);
            gl.attachShader(mobiusShaderProgram, mobiusFragmentShader);
            gl.linkProgram(mobiusShaderProgram);

            if (!gl.getProgramParameter(mobiusShaderProgram, gl.LINK_STATUS)) {
                alert("Could not initialise shaders");
            }

            mobiusShaderProgram.vertexPositionAttribute = gl.getAttribLocation(mobiusShaderProgram, "aVertexPosition");
            gl.enableVertexAttribArray(mobiusShaderProgram.vertexPositionAttribute);

            mobiusShaderProgram.textureCoordAttribute = gl.getAttribLocation(mobiusShaderProgram, "aTextureCoord");
            gl.enableVertexAttribArray(mobiusShaderProgram.textureCoordAttribute);

            mobiusShaderProgram.pMatrixUniform = gl.getUniformLocation(mobiusShaderProgram, "uPMatrix");
            mobiusShaderProgram.mvMatrixUniform = gl.getUniformLocation(mobiusShaderProgram, "uMVMatrix");
            mobiusShaderProgram.samplerUniform = gl.getUniformLocation(mobiusShaderProgram, "uSampler");
            mobiusShaderProgram.textureOffset = gl.getUniformLocation(mobiusShaderProgram, "vTextureOffset");
            mobiusShaderProgram.mobiusA = gl.getUniformLocation(mobiusShaderProgram, "uMobiusA");
            mobiusShaderProgram.mobiusB = gl.getUniformLocation(mobiusShaderProgram, "uMobiusB");
            mobiusShaderProgram.mobiusC = gl.getUniformLocation(mobiusShaderProgram, "uMobiusC");
            mobiusShaderProgram.mobiusD = gl.getUniformLocation(mobiusShaderProgram, "uMobiusD");

            // For circle gradient
            var basicVertexShader = getShader(gl, "shader-basic-vertex");
            var circleGradientVertexShader = getShader(gl, "shader-circlegradient-fragment");

            circleGradientShaderProgram = gl.createProgram();
            gl.attachShader(circleGradientShaderProgram, basicVertexShader);
            gl.attachShader(circleGradientShaderProgram, circleGradientVertexShader);
            gl.linkProgram(circleGradientShaderProgram);

            if (!gl.getProgramParameter(circleGradientShaderProgram, gl.LINK_STATUS)) {
                alert("Could not initialise CircleGradientShaderProgram");
            }

            circleGradientShaderProgram.vertexPositionAttribute = gl.getAttribLocation(circleGradientShaderProgram, "aVertexPosition");
            gl.enableVertexAttribArray(circleGradientShaderProgram.vertexPositionAttribute);

            circleGradientShaderProgram.pMatrixUniform = gl.getUniformLocation(mobiusShaderProgram, "uPMatrixColor");
            circleGradientShaderProgram.mvMatrixUniform = gl.getUniformLocation(mobiusShaderProgram, "uMVMatrixColor");

            circleGradientShaderProgram.color0 = gl.getUniformLocation(circleGradientShaderProgram, "uColor0");
            circleGradientShaderProgram.color1 = gl.getUniformLocation(circleGradientShaderProgram, "uColor1");
            circleGradientShaderProgram.r0 = gl.getUniformLocation(circleGradientShaderProgram, "uR0");
            circleGradientShaderProgram.r1 = gl.getUniformLocation(circleGradientShaderProgram, "uR1");

        }

        var disc;
        function initGeometry() {
            //	var c = Circle.prototype.create(Complex.one, 1);
            p = parseInt(doc.pField.value);
            q = parseInt(doc.qField.value);
            disc = new Disc(new Region(p, q), "", true);
        }

        var mvMatrix = mat4.create();
        var mvMatrixStack = [];
        var pMatrix = mat4.create();

        function mvPushMatrix() {
            var copy = mat4.create();
            mat4.set(mvMatrix, copy);
            mvMatrixStack.push(copy);
        }

        function mvPopMatrix() {
            if (mvMatrixStack.length == 0) {
                throw "Invalid popMatrix!";
            }
            mvMatrix = mvMatrixStack.pop();
        }

        function initBuffers() {

        }

        var textureOffset = Complex.zero;
        //	var motionOffset = Complex.zero;
        var motionIncrement = Complex.zero;
        var motionMobius = Mobius.identity;
        //	var angleOffset = 0;
        var angleIncrement = 0;

        function drawScene() {
            //     this.canvas.width = window.innerWidth;
            //     this.canvas.height = window.innerWidth;

            gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            gl.enable(gl.BLEND);
            gl.disable(gl.DEPTH_TEST); 			// Turn Depth Testing Off

            //      mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
            mat4.ortho(-1, 1, -1, 1, 0.1, 100.0, pMatrix);
            mat4.identity(mvMatrix);
            mat4.translate(mvMatrix, [0.0, 0.0, -5.0]);

            disc.draw(motionMobius, textureOffset, mobiusShaderProgram, circleGradientShaderProgram);

        }

        var startTime = 0;
        var lastTime = 0;

        function animate() {
            var timeNow = new Date().getTime();
            if (startTime != 0) {
                var elapsed = timeNow - startTime;
                elapsed *= 0.00001;

                sample();

                textureOffset = new Complex([Math.cos(3.0 * elapsed), Math.sin(2.0 * elapsed)]);

                var motionMobiusIncrement = Mobius.multiply(
						Mobius.createRotation(angleIncrement),
						Mobius.createDiscTranslation(Complex.zero, motionIncrement)
					);

                motionMobius = Mobius.multiply(
						motionMobiusIncrement,
						motionMobius
					);

                var flipEdge;
                var currentFace = disc.initialFace.transform(motionMobius);
                do {
                    flipEdge = null;
                    flipTrans = Mobius.identity;

                    for (var i = 0; i < currentFace.edges.length; i++) {
                        var edge = currentFace.edges[i];
                        if (edge.isConvex()) {
                            flipEdge = edge;
                            break;
                        }
                    }

                    var image;
                    if (flipEdge != null) {
                        flipTrans = Mobius.multiply(flipTrans, flipEdge.Circline.asMobius());
                        image = currentFace.conjugate().transform(flipTrans);

                        currentFace = image;
                    }

                } while (flipEdge != null);

                // curentFace seems to accumulate rounoff error; create a new one from it's new position
                var toCenter = Mobius.createDiscAutomorphism(currentFace.center, 0);
                var angle = currentFace.vertices[0].transform(toCenter).argument();
                var seedFaceTrans = Mobius.multiply(
						Mobius.createDiscAutomorphism(currentFace.center, 0),
						Mobius.createRotation(angle - disc.initialFace.vertices[0].argument())
					);

                motionMobius = seedFaceTrans;
            } else {
                startTime = timeNow;
            }
            lastTime = timeNow;
        }

        var lastTickTime = new Date().getTime();
        function tick() {
            requestAnimFrame(tick);

            var startTime = new Date().getTime();
            drawScene();
            var sceneTime = new Date().getTime();
            animate();
            var animateTime = new Date().getTime();

            doc.framerate.innerHTML = "draw: " + (sceneTime - startTime) + " animate: " + (animateTime - sceneTime) + " loop: " + (animateTime - lastTickTime);
            lastTickTime = animateTime;
        }

        var isDragging = false;
        var isDraggingAngle = false;
        var thisMousePos = Complex.zero;
        var initialMousePos = Complex.zero;

        function handleMouseDown(event) {
            isDragging = true;
            thisMousePos = mousePos(event)
            if (thisMousePos.modulusSquared() > 0.98) {
                isDraggingAngle = true;
            }

            initialMousePos = thisMousePos;
        }

        function handleMouseUp(event) {
            isDragging = false;
            isDraggingAngle = false;
        }

        function handleMouseMove() {
            if (!isDragging) {
                return;
            }

            thisMousePos = mousePos();
        }

        function sample() {
            if (!isDragging) {
                return;
            }

            if (isDraggingAngle) {
                angleIncrement = thisMousePos.argument() - initialMousePos.argument();
            } else {
                if (thisMousePos.modulusSquared() > 0.98) {
                    thisMousePos = Complex.createPolar(0.98, thisMousePos.argument());
                }
                motionIncrement = Complex.subtract(thisMousePos, initialMousePos);
            }

            initialMousePos = thisMousePos;
        }

        //   var canvasSize = 800;
        function mousePos() {
            return new Complex([2 * window.event.clientX / canvas.width - 1, 1 - 2 * window.event.clientY / canvas.height]);
        }

        function reset() {
            var startTime = new Date().getTime();
            initGeometry();
            doc.output.innerHTML = "Initialization: " + (new Date().getTime() - startTime);

            initBuffers();
        }

        var doc;
        function webGLStart() {
            doc = new Doc();
            initGL(doc.canvas);
            initShaders();

            reset();

            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.enable(gl.DEPTH_TEST);

            canvas.onmousedown = handleMouseDown;
            document.onmouseup = handleMouseUp;
            document.onmousemove = handleMouseMove;

            tick();
        }

//        window.onload = window.onresize = function () {
//            var pw = canvas.parentNode.clientWidth;
//            var ph = canvas.parentNode.clientHeight;

//            canvas.height = pw * 0.8 * (canvas.height / canvas.width);
//            canvas.width = pw * 0.8;
//            canvas.style.top = (ph - canvas.height) / 2 + "px";
//            canvas.style.left = (pw - canvas.width) / 2 + "px";


            ////            var C = 1;        // canvas width to viewport width ratio
            ////            var W_TO_H = 1;   // canvas width to canvas height ratio

            ////            // For IE compatibility http://www.google.com/search?q=get+viewport+size+js
            ////            var viewportWidth = window.innerWidth;
            ////            var viewportHeight = window.innerHeight;

            ////            var canvasWidth = viewportWidth * C;
            ////            var canvasHeight = canvasWidth / W_TO_H;
            ////            canvas.style.position = "fixed";
            ////            canvas.setAttribute("width", canvasWidth);
            ////            canvas.setAttribute("height", canvasHeight);
            ////            canvas.style.top = (viewportHeight - canvasHeight) / 2;
            ////            canvas.style.left = (viewportWidth - canvasWidth) / 2;

            ////            window.ctx = canvas.getContext("2d");
            ////            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            ////            ctx.fillStyle = 'yellow';
            ////            ctx.moveTo(0, canvasHeight / 2);
            ////            ctx.lineTo(canvasWidth / 2, 0);
            ////            ctx.lineTo(canvasWidth, canvasHeight / 2);
            ////            ctx.lineTo(canvasWidth / 2, canvasHeight);
            ////            ctx.lineTo(0, canvasHeight / 2);
            ////            ctx.fill()
   //     }

        function Doc() {
            this.canvas = document.getElementById("canvas");
            this.controls = document.getElementById("controls");
            this.output = document.getElementById("output");
            this.framerate = document.getElementById("framerate");
            this.pField = document.getElementById("p");
            this.qField = document.getElementById("q");
            this.resetButton = document.getElementById("reset");
            this.resetButton.onclick = reset;
        }

    </script>
    <style type="text/css">
        body
        {
            background-color: #000;
            font-family: 'Helvetica Neue' , Helvetica, Arial, sans-serif;
            font-size: 15px;
            font-weight: 700;
     color: white;
            font-family: 'Doppio One' , 'Helvetica Neue' , Helvetica, Arial, sans-serif;
            padding: 0px;
        }
        
        html, body
        {
            width: 100%;
            height: 100%;
            margin: 0px;
        }
        #controls
        {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 250px;
            margin: 0 0 0 0;
            background-color: #222;
            padding: 0 0 0 10px;           
        }
    </style>
</head>
<body onload="webGLStart();">
    <canvas id="canvas" style="border: none;" width="800" height="800"></canvas>
    <div id="controls">
        <p id="framerate">
        </p>
        <p id="output">
        </p>
        <p>
            <input type='text' id='p' value='5' size='5' />
            <input type='text' id='q' value='5' size='5' />
            <input type='button' id='reset' value="reset" />
        </p>
    </div>
</body>
</html>
